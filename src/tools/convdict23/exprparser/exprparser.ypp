/*
See http://dinosaur.compilertools.net/bison/bison_5.html.
*/

%skeleton "lalr1.cc"      
%defines
%define "parser_class_name" "ExprParser"

%{
#include <math.h>
#include "exprdriver.h"

#define yylex exprlex
%}

%parse-param { ExprDriver& driver }
%lex-param   { ExprDriver& driver }
%locations
%debug
%error-verbose

/* This defines the type of yylval */
%union {
  double num;
}

%{
yy::ExprParser::token_type exprlex(yy::ExprParser::semantic_type* yylval,
        yy::ExprParser::location_type* /*yylloc*/, ExprDriver& /*driver*/);
%} 

/* BISON Declarations */
%token END 0 "end of file"
%token NUM LEFT_PAREN RIGHT_PAREN

%left LESSER LARGER LESSER_EQUAL LARGER_EQUAL
%left EQUALS
%left ROUND
%left MINUS PLUS
%left MULTIPLY DIVIDE MOD
%left NEG POS /* unary plus and minus */
%right POW

%type <num> input exp NUM
 
%start input
 
%% /* Grammar rules and actions follow */

input:  exp END                { $$ = $1; driver.setResult($1); };

exp:      NUM                  { $$ = $1;          }
        | exp PLUS exp         { $$ = $1 + $3;     }
        | exp MINUS exp        { $$ = $1 - $3;     }
        | MINUS exp %prec NEG  { $$ = -$2;         }
        | PLUS  exp %prec POS  { $$ = $2;          }
        | exp LESSER exp       { $$ = ($1 < $3 ? 1 : 0); }
        | exp LARGER exp       { $$ = ($1 > $3 ? 1 : 0); }
        | exp LESSER_EQUAL exp { $$ = ($1 <= $3 ? 1 : 0); }
        | exp LARGER_EQUAL exp { $$ = ($1 >= $3 ? 1 : 0); }
        | exp MULTIPLY exp     { $$ = $1 * $3; }
        | exp DIVIDE exp       { $$ = $1 / $3; }
        | LEFT_PAREN exp RIGHT_PAREN { $$ = $2; }
        | exp ROUND exp        { double i = pow(10, $3); $$ = round($1 * i) / i; }
        | exp POW exp          { $$ = pow($1, $3); }
        | exp MOD exp          { $$ = (int)$1 % (int)$3; } 
        | exp EQUALS exp       { $$ = ($1 == $3 ? 1 : 0); }
;
        
%%
void yy::ExprParser::error(const yy::ExprParser::location_type& l, const std::string& m)
{
  driver.error(l, m);
}
